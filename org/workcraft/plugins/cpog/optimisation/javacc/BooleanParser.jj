/**
 * JavaCC file
 */
 
options {
  JDK_VERSION = "1.5";
  STATIC = false;
}
PARSER_BEGIN(BooleanParser)
package org.workcraft.plugins.cpog.optimisation.javacc;

import java.util.Collection;
import java.util.HashMap;
import java.io.Reader;
import java.io.StringReader;

import org.workcraft.plugins.cpog.optimisation.booleanvisitors.FormulaToString;
import org.workcraft.plugins.cpog.optimisation.expressions.*;
import org.workcraft.plugins.cpog.optimisation.*;
import org.workcraft.util.Func;

public class BooleanParser {
  public BooleanParser(Reader reader, Func<String, ? extends BooleanFormula> vars)
  {
    this (reader);
    this.vars = vars;
  }
  BooleanWorker worker = new org.workcraft.plugins.cpog.optimisation.expressions.CleverBooleanWorker();
  Func<String, ? extends BooleanFormula> vars;
  BooleanFormula var(String name) throws ParseException
  {
	BooleanFormula result = vars.eval(name);
    if (result == null)
    throw new ParseException("Undefined variable: '" + name + "'");
    return result;
  }
  BooleanFormula constant(String value)
  {
    return "0".equals(value) ? worker.zero() : worker.one();
  }
  BooleanFormula and(BooleanFormula a, BooleanFormula b)
  {
    return worker.and(a, b);
  }
  BooleanFormula or(BooleanFormula a, BooleanFormula b)
  {
    return worker.or(a, b);
  }
  BooleanFormula eq(BooleanFormula a, BooleanFormula b)
  {
    return worker.iff(a, b);
  }
  BooleanFormula imply(BooleanFormula a, BooleanFormula b)
  {
    return worker.imply(a, b);
  }
  BooleanFormula xor(BooleanFormula a, BooleanFormula b)
  {
    return worker.xor(a, b);
  }
  BooleanFormula not(BooleanFormula a)
  {
    return worker.not(a);
  }
  
  public static BooleanFormula parse(String text, Func<String, ? extends BooleanFormula> vars) throws ParseException
  {
    return new BooleanParser(new StringReader(text), vars).formula();
  }

  public static BooleanFormula parse(String text, Collection <? extends BooleanVariable> variables) throws ParseException
  {
    final HashMap<String, BooleanVariable> map = new HashMap<String, BooleanVariable>();
    for(BooleanVariable var : variables)
	  map.put(var.getLabel(), var);
    return parse(text, new Func<String, BooleanVariable>()    {
      public BooleanVariable eval(String label)      {
        return map.get(label);      }    });
  }

  public static void main(String [] args) throws Exception
  {
    System.out.println(FormulaToString.toString(new BooleanParser(System.in).formula()));
  }
}
PARSER_END(BooleanParser)

SKIP :
{
 	" "
|	"\r"
|	"\t"
|	"\n"
}
TOKEN : /* OPERATORS */
{
  	< EQUALS: "eq" | "=" | "==" | "<->" | "<=>" >
|  	< NOTEQUALS: "neq" | "!=" >
|  	< IMPLIES: "imp" | "=>" | "\u21d2" | "->" >
|  	< OR: "or" | "|" | "+" | "\u2228" >
|  	< XOR: "xor" | "^" | "\u2295" >
|	< AND: "and" | "&" | "*" | "\u2227" | "\u2022" >
|	< NOT: "not" | "!" | "¬" >
|   < POSTNOT: "'" >
}
TOKEN :
{
    < CONSTANT: "0"|"1" >
|   < VARIABLE: ["A"-"Z","a"-"z","_"](["_","A"-"Z","a"-"z","0"-"9","[","]"])* >
}
BooleanFormula formula() :
{
  	BooleanFormula result;
  	BooleanFormula op;
}
{
  result = eqOp() ( < EQUALS > op = eqOp()  { result = eq(result, op); } )*
  { return result; }}

BooleanFormula eqOp() :
{
  	BooleanFormula result;
  	BooleanFormula op;
}
{
  result = neqOp() ( < NOTEQUALS > op = neqOp()
  { result = xor(result, op); } ) *
  { return result; }
}

BooleanFormula neqOp() :
{
  	BooleanFormula result;
  	BooleanFormula op;
}
{
  result = implyOp() [ < IMPLIES > op = implyOp()
  { result = imply(result, op); } ]
  { return result; }
}

BooleanFormula implyOp() :
{
  	BooleanFormula result;
  	BooleanFormula op;
}
{
  result = orOp() ( < OR > op = orOp()
  { result = or(result, op); } ) *
  { return result; }
}

BooleanFormula orOp() :
{
  	BooleanFormula result;
  	BooleanFormula op;
}
{
  result = xorOp() ( < XOR > op = xorOp()
  { result = xor(result, op); } ) *
  { return result; }
}

BooleanFormula xorOp() :
{
  	BooleanFormula result;
  	BooleanFormula op;
}
{
  result = andOp() ( < AND > op = andOp()
  { result = and(result, op); } ) *
  { return result; }
}

BooleanFormula andOp() :
{
  boolean inverse = false;
  BooleanFormula result;}
{
  	(< NOT > { inverse = !inverse; } )*
  	result = literal()
  	(< POSTNOT > { inverse = !inverse; } )*
  	{ return inverse ? not(result) : result; }
}

BooleanFormula literal() :
{
  Token t;
  BooleanFormula result;}
{
   (     t = < VARIABLE >
	{ result = var(t.image); }
    |
    t = < CONSTANT >
	{ result = constant(t.image); }    | "(" result = formula() ")"
  )
  { return result; }}